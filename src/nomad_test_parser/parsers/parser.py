from typing import (
    TYPE_CHECKING,
)

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import (
        EntryArchive
    )
    from structlog.stdlib import (
        BoundLogger,
    )

from nomad.config import config
from nomad.datamodel.metainfo.workflow import Workflow
from nomad.parsing.parser import MatchingParser
import numpy as np
#importa ArchiveSection
from nomad.metainfo import Section, Quantity  # Added import
from nomad.datamodel.data import ArchiveSection # Added import, replaces commented out #importa ArchiveSection
from nomad.datamodel.data import EntryData
from baseclasses.solar_energy import JVMeasurement
import os;
from baseclasses.helper.utilities import set_sample_reference, create_archive, get_entry_id_from_file_name, get_reference
import datetime;
from nomad.datamodel.metainfo.basesections import (
    Entity,
)
from nomad.datamodel.metainfo.annotations import (
    ELNAnnotation,
)

class RawFileUNITOV(EntryData):
    processed_archive = Quantity(
        type=Entity,
        a_eln=ELNAnnotation(
            component='ReferenceEditQuantity',
        )
    )


class UNITOV_JVmeasurement(JVMeasurement, RawFileUNITOV):
    m_def = Section(
        a_eln=dict(
            hide=[
                'lab_id', 'solution',
                'users',
                'author',
                'certified_values',
                'certification_institute',
                'end_time', 'steps', 'instruments', 'results',
            ],
            properties=dict(
                order=[
                    "name",
                    "data_file",
                    "active_area",
                    "intensity",
                    "integration_time",
                    "settling_time",
                    "averaging",
                    "compliance",
                    "samples"])),
        a_plot=[
            {
                'x': 'jv_curve/:/voltage',
                'y': 'jv_curve/:/current_density',
                'layout': {
                    "showlegend": True,
                    'yaxis': {
                        "fixedrange": False},
                    'xaxis': {
                        "fixedrange": False}},
            }])

    def normalize(self, archive, logger):
        if self.data_file:
            # todo detect file format
            from baseclasses.helper.utilities import get_encoding
            with archive.m_context.raw_file(self.data_file, "br") as f:
                encoding = get_encoding(f)

            with archive.m_context.raw_file(self.data_file, "tr", encoding=encoding) as f:
                from nomad_test_parser.parsers.file_reading import read_file_jv_data
                from baseclasses.helper.archive_builder.jv_archive import get_jv_archive

                jv_dict, location = read_file_jv_data(f)

                self.location = location
                get_jv_archive(jv_dict, self.data_file, self)

        super(UNITOV_JVmeasurement,
              self).normalize(archive, logger)




configuration = config.get_plugin_entry_point(
    'nomad_test_parser.parsers:parser_entry_point'
)

class SimpleOutput(ArchiveSection):
    """
    A simple section to store basic output from this parser.
    """
    m_def = Section(label='Simple Parser Output') # Defines the section metadata

    message = Quantity(
        type=str,
        description='A simple message generated by the parser.'
    )
    example_value = Quantity(
        type=np.float64,
        description='An example numerical value processed by the parser.'
    )
    parsed_mainfile_path = Quantity(
        type=str,
        description='The path of the mainfile that was parsed.'
    )





class NewParser(MatchingParser):
    def parse(
        self,
        mainfile: str,
        archive: 'EntryArchive',
        logger: 'BoundLogger',
        child_archives: dict[str, 'EntryArchive'] = None,
    ) -> None:
        logger.info('NewParser.parse', parameter=configuration.parameter)
        print("PIPPO ==========================================")
        print("PIPPO ==========================================")
        print("PIPPO ==========================================")
        print("PIPPO ==========================================")

        # 1. Create an instance of your custom section
        my_simple_output_data = SimpleOutput()

        # 2. Populate the section with some data
        #    (In a real parser, this data would come from parsing the 'mainfile')
        my_simple_output_data.message = 'This is a test message from NewParser.'
        my_simple_output_data.example_value = 123.456
        my_simple_output_data.parsed_mainfile_path = mainfile

        # 3. Assign your custom section to archive.data
        #    archive.data is the typical place for the primary data extracted by the parser.
        archive.data = my_simple_output_data


class JVParser(MatchingParser):
    def parse(
        self,
        mainfile: str,
        archive: 'EntryArchive',
        logger: 'BoundLogger',
        child_archives: dict[str, 'EntryArchive'] = None,
    ) -> None:
        logger.info('NewParser.parse', parameter=configuration.parameter)
        print("Parse JV curve ==========================================")

        # 1. Create an instance of your custom section
        #entry = UNITOV_JVmeasurement()
        notes = ''

        # 2. Populate the section with some data
        #    (In a real parser, this data would come from parsing the 'mainfile')

        #archive.metadata.entry_name = os.path.basename(mainfile)

        #mainfile_split = mainfile.split('.');

        #if not mainfile_split[-1] in ["nk"]:
        #    search_id = mainfile_split[0]
        #    set_sample_reference(archive, entry, search_id)

        #    entry.name = f"{search_id} {notes}"
        #    entry.description = f"Notes from file name: {notes}"

        #if not measurment_type in ["uvvis", "sem", "SEM"]:
        #    entry.data_file = os.path.basename(mainfile)



        #file_name = f'{os.path.basename(mainfile)}.archive.json'
        #eid = get_entry_id_from_file_name(file_name, archive)

        #archive.data = UNITOV_JVmeasurement(processed_archive=get_reference(archive.metadata.upload_id, eid))
        archive.data = UNITOV_JVmeasurement()
        archive.data.message = 'This is a test JV measurement parsing.'
        archive.data.datetime = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")

        #create_archive(entry, archive, file_name)

        # 3. Assign your custom section to archive.data
        #    archive.data is the typical place for the primary data extracted by the parser.
        #archive.data = my_simple_output_data
